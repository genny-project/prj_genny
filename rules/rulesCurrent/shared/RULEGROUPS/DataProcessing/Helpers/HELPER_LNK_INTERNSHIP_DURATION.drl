package life.genny.rules;

import life.genny.qwandautils.QwandaUtils;
import life.genny.qwanda.message.QDataAnswerMessage;
import life.genny.qwanda.message.QDataBaseEntityMessage;
import life.genny.models.GennyToken;
import life.genny.rules.QRules;
import life.genny.utils.BaseEntityUtils;
import life.genny.qwanda.Answer;
import life.genny.qwanda.Answers;
import io.vertx.core.json.JsonObject;
import java.util.Map;
import java.util.HashMap;
import life.genny.utils.VertxUtils;
import life.genny.qwanda.attribute.EntityAttribute;
import life.genny.qwanda.entity.BaseEntity;
import life.genny.qwandautils.JsonUtils;
import org.apache.commons.lang3.StringUtils;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.io.UnsupportedEncodingException;
import life.genny.utils.DropdownUtils;
import java.util.List;
import java.util.ArrayList;

rule "HELPER_LNK_INTERNSHIP_DURATION"
	ruleflow-group 'DataProcessing'
	salience 5000
	when
		beUtils : BaseEntityUtils()
		answer : Answer( attributeCode == "LNK_INTERNSHIP_DURATION")
		serviceToken : GennyToken( code == "PER_SERVICE")
		userToken : GennyToken( code != "PER_SERVICE")

	then
		System.out.println(drools.getRule().getName() + " triggered");
		
		String sourceCode = beUtils.getGennyToken().getUserCode();
		System.out.println("sourceCode :: " + sourceCode);
		
		String targetCode = answer.getTargetCode();
		System.out.println("targetCode :: " + targetCode);
		
		String value = answer.getValue();
		System.out.println("value :: " + value);
		
		String code = beUtils.cleanUpAttributeValue(value);
		System.out.println("code  :: " + code);

		BaseEntity targetBe = beUtils.getBaseEntityByCode(code);
		String durationStr = "";
		if(targetBe != null){
			durationStr = targetBe.getValue("PRI_WHICH_DAYS_STRIPPED", null);
			System.out.println("durationStr = " +durationStr);		
			if(durationStr != null){
				Answer ans = new Answer(sourceCode, targetCode, "PRI_ASSOC_DURATION", durationStr);
				beUtils.saveAnswer(ans);
				VertxUtils.sendToFrontEnd(userToken, ans);
			}
		}


		targetBe = beUtils.getBaseEntityByCode(targetBe.getCode());

		LocalDate sdc = beUtils.getBaseEntityValueAsLocalDate("APP_1A262724-A988-4B13-96C5-C113FDA2DDCD", "PRI_WORD_START_DATE");
		System.out.println("sdc = " +sdc);

		String start_date = sdc.toString();
		System.out.println("start_date = " +start_date);
		
		String wdsStr = targetBe.getValue("PRI_WHICH_DAYS_STRIPPED", null);
		System.out.println("wdsStr = " + wdsStr);

		String nullValue = null;
				
		if (start_date == null || durationStr == null || wdsStr == null) {
			if (start_date == null) {nullValue = "Start Date";} 	if (durationStr == null) {nullValue = "Duration";}  	if (wdsStr == null) {nullValue = "Which Days";}
			System.out.println("Required value is Null. Can't continue");
			QCmdMessage msg = new QCmdMessage("TOAST", "ERROR");
			msg.setMessage("Sorry can't calculate the End Date as we are missing: " + nullValue);
			msg.setToken(beUtils.getGennyToken().getToken());
			msg.setSend(true);
			VertxUtils.writeMsg("webcmds", msg);
			
		} else {
		
			int durationInt = Integer.parseInt(durationStr);
			int dayz = 7 * durationInt;
			System.out.println("dayz = " + dayz);
			
			int dayzAdj = dayz - 7;
			System.out.println("dayzAdj = " + dayzAdj);
			
			Calendar c = Calendar.getInstance();
			String DATE_FORMAT = "yyyy-MM-dd";
			DateFormat df = new SimpleDateFormat(DATE_FORMAT);
			
			Date startDate = df.parse(start_date.trim());
			System.out.println("startDate = " + startDate);

			c.setTime(startDate);
			c.add(Calendar.DATE, dayz);
			
			String toDate = df.format(c.getTime());
			System.out.println("endDate minus dayzAdj = " + toDate);
			
			
			/*wdsStr = "Monday, Friday, Thursday, Wednesday";*/
			
			HashMap<String, Integer> daysOfWeek = new HashMap<String, Integer>();
				daysOfWeek.put("Monday", 1);
				daysOfWeek.put("Tuesday", 2);
				daysOfWeek.put("Wednesday", 3);
				daysOfWeek.put("Thursday", 4);
				daysOfWeek.put("Friday", 5);
				daysOfWeek.put("Open to any combination of days", 5);
			System.out.println(daysOfWeek);
		
		
			String lastDay = "Friday";
			int lastDayKey = 0;
			
			String[] whichDays = wdsStr.split(", ");
			for (int i = 0; i < whichDays.length; i++) {
				/*System.out.println("Day = " + whichDays[i] + " with key = " + daysOfWeek.get(whichDays[i]));*/
			
				if (daysOfWeek.get(whichDays[i]) >= lastDayKey) {
					lastDayKey = daysOfWeek.get(whichDays[i]);
					lastDay = whichDays[i];
					System.out.println("lastDayKey = " + lastDayKey);
					System.out.println("lastDay = " +lastDay);
				} else {
					System.out.println("Not new day. lastDay = " +lastDay);
			}
			}
			
			
			/*int dayOfWeek = c.get(Calendar.DAY_OF_WEEK);
			System.out.println("dayOfWeek = " + dayOfWeek);*/
		
			String[] toDateSplt = toDate.split("-");
			
			int year = Integer.parseInt(toDateSplt[0]);
			int month = Integer.parseInt(toDateSplt[1]) -1;
			int day = Integer.parseInt(toDateSplt[2]); 
			
			System.out.println("endDate minus dayzAd :: year = " + year + " :: month = " + month + " :: day = " + day);
			
			Calendar date1 = Calendar.getInstance();
			date1.set(year, month, day);
			System.out.println("date1 = " + date1.getTime());
			
			switch (lastDay) {
				case "Monday":
				
				while (date1.get(Calendar.DAY_OF_WEEK) != Calendar.MONDAY) {
					date1.add(Calendar.DATE, 1);
					System.out.println("Monday case: " +date1.getTime());
				}
				System.out.println("endDate = " + date1.getTime());
				break;
				
				case "Tuesday":
				
				while (date1.get(Calendar.DAY_OF_WEEK) != Calendar.TUESDAY) {
					date1.add(Calendar.DATE, 1);
					System.out.println("Tuesday case: " +date1.getTime());
				}
				System.out.println("endDate = " + date1.getTime());
				break;
				
				case "Wednesday":
				
				while (date1.get(Calendar.DAY_OF_WEEK) != Calendar.WEDNESDAY) {
					date1.add(Calendar.DATE, 1);
					System.out.println("Wednesday case: " +date1.getTime());
				}
				System.out.println("endDate = " + date1.getTime());
				break;
				
				case "Thursday":
				
				while (date1.get(Calendar.DAY_OF_WEEK) != Calendar.THURSDAY) {
					date1.add(Calendar.DATE, 1);
					System.out.println("Thursday case: " +date1.getTime());
				}
				System.out.println("endDate = " + date1.getTime());
				break;
				
				case "Friday":
				
				while (date1.get(Calendar.DAY_OF_WEEK) != Calendar.FRIDAY) {
					date1.add(Calendar.DATE, 1);
					System.out.println("Friday case: " +date1.getTime());
				}
				System.out.println("endDate = " + date1.getTime());
				break;
				
				case "Open to any combination of days":
				
				while (date1.get(Calendar.DAY_OF_WEEK) != Calendar.FRIDAY) {
					date1.add(Calendar.DATE, 1);
					System.out.println("Friday case: " +date1.getTime());
				}
				System.out.println("endDate = " + date1.getTime());
				break;
				
				default:
				
				while (date1.get(Calendar.DAY_OF_WEEK) != Calendar.FRIDAY) {
					date1.add(Calendar.DATE, 1);
					System.out.println("Default case: " +date1.getTime());
				}
				System.out.println("endDate = " + date1.getTime());
			}
			
			/* Save Answer */
			LocalDate endDate = date1.getTime().toInstant().atZone(ZoneId.systemDefault()).toLocalDate();
			Answer endDateAnswer = new Answer(sourceCode, targetCode, "PRI_END_DATE", endDate);
			beUtils.saveAnswer(endDateAnswer);
			
			
			/* Prepare Question and Ask */
			Attribute attr = RulesUtils.getAttribute("PRI_END_DATE", serviceToken);
			
			Question endDateQues = new Question("PRI_END_DATE", "End Date", attr, true);
			Ask endDateAsk = new Ask(endDateQues, sourceCode, targetCode);
			
			/* Send Disable for this Ask */
			endDateAsk.setDisabled(true);
			
			QDataAskMessage endDateAskMsgDisable = new QDataAskMessage(endDateAsk);
			endDateAskMsgDisable.setToken(userToken.getToken());
			VertxUtils.writeMsg("webcmds", endDateAskMsgDisable);
			
			/* Send enable for this Ask */
			endDateAsk.setDisabled(false);
			
			QDataAskMessage endDateAskMsgEnable = new QDataAskMessage(endDateAsk);
			endDateAskMsgEnable.setToken(userToken.getToken());
			VertxUtils.writeMsg("webcmds", endDateAskMsgEnable);

			/* Send Answer to Front End */
			VertxUtils.sendToFrontEnd(userToken, endDateAnswer);
		}
end